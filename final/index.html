<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Paper Simulation: Milestone | CS 184</title>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
</head>
<body>
    <header>
        <div class="header-content">
            <h1>Paper Simulation: Milestone</h1>
            <div class="team-info">Siva Tanikonda, Krishna Mani, Max Tse, Brandon Huang (Team 16)</div>
            
            <div class="links-section">
                <div class="link-card">
                    <a href="https://docs.google.com/presentation/d/1H96KwcN61NkM5BgHfjxeoicezMRdKBxtncHrwsgJbNM/edit?usp=sharing" target="_blank">View Slides</a>
                </div>
                <div class="link-card">
                    <a href="https://youtu.be/uYZeY-sm8kY" target="_blank">Watch Video</a>
                </div>
                <div class="link-card">
                    <a href="https://siva-tanikonda.github.io/cs184-paper-wp" target="_blank">Project Website</a>
                </div>
            </div>
        </div>
    </header>

    <div class="container">
        <section id="abstract">
            <h2>Abstract</h2>
            <p>This project explores the simulation of paper-like materials through cloth simulation techniques, focusing on achieving realistic folding and bending behaviors. Building upon the CS 184 Project 4 cloth simulation framework, we implemented a more robust physics engine based on implicit integration and enhanced constraint modeling. We replaced the rectangular grid structure with support for arbitrary triangle meshes loaded from OBJ files, and introduced specialized forces to approximate paper stiffness and bending resistance. While we initially planned to implement full origami folding capabilities, we strategically narrowed our scope to focus on the underlying physics of paper-like materials. Our approach successfully demonstrates that cloth simulation techniques can be adapted to model stiffer materials with realistic folding behavior without implementing complex remeshing or explicit fold creation.</p>
        </section>

        <section id="summary">
            <h2>Summary</h2>
            <p>After looking through the paper we planned to use in the proposal (<i>Folding and Crumpling of Adaptive Sheets</i>), we realized that the complexity of the paper was too high for us to reasonably complete the project within the 4-week timeframe. So, we spent some time finding an alternate, simpler implementation of paper simulation: <i>Discrete Shells Origami</i>. This paper required us to first implement a new cloth simulation/mesh framework outlined in another paper: <i>Large Steps in Cloth Simulation</i>. We decided to use our finished CS 184 Project 4 code as a base for our project, but with the following changes:</p>
            
            <ul>
                <li>We added a system to load meshes from <code>.obj</code> files rather than simply having rectangular cloth. This also naturally resulted in the arrangement of springs being different from the Project 4 code. Instead of each spring being represented as a 3D line segment in our mesh, the springs are now not separate entities from the triangles, but rather, each triangle has its own constants for shearing, bending, and stretching forces.</li>
                
                <li>We changed the integrator from using Verlet integration to using the implicit integrator outlined in the <i>Large Steps in Cloth Simulation</i> paper. This integrator utilizes the below formula for calculating the next position and velocity of our point masses.
                \[\begin{bmatrix}\Delta\vec{x}\\\Delta\vec{v}\end{bmatrix}=h\begin{bmatrix}\vec{v}_t+\Delta\vec{v}\\\mathbf{M}^{-1}\vec{f}\left(\vec{x}_t+\Delta\vec{x},\vec{v}_t+\Delta\vec{v}\right)\end{bmatrix}\]
                where \(\vec{f}(\cdot,\cdot)\) is the force vector at a given position and velocity, \(\mathbf{M}\) is a matrix that maps an acceleration vector to a net force vector applied to the point mass, \(t\) represents our current timestep, and \(t+h\) represents the next timestep. Another key benefit of this simulation technique is that it runs faster than typical explicit integrators (this result is outlined in the paper).</li>
            </ul>
            
            <p>So far, we have implemented stretch and shearing constraint springs in our mesh, but have yet to handle bending constraints. In order to begin working on simulating paper, we need to implement the bending constraints.</p>

            <p>To be more specific, here are the changes we made to the Project 4 code:</p>
            <ul>
                <li>We added a function <code>buildFromOBJ()</code> to <code>cloth.cpp</code> to load an arbitrary <code>.obj</code> file and place point masses according to the file's mesh structure.</li>
                <li>We created the new files <code>physics.cpp</code> and <code>physics.h</code> that calculate stretch constraints and shearing constraints for each triangle in our mesh. The implementation is outlined in the <i>Large Steps in Cloth Simulation</i> paper.</li>
                <li>We changed <code>buildClothMesh()</code> in <code>cloth.cpp</code> to build our cloth mesh according to the mesh constructed by <code>buildFromOBJ()</code>. In this function, we also constructed a world-to-object space matrix \(\mathbf{D}_{u,v}\) for each triangle, which we use in our stretch and shear constraint calculations.</li>
            </ul>
        </section>

        <section id="technical-approach">
            <h2>Technical Approach</h2>
            <p>Our project set out to simulate realistic paper behavior through a cloth-based framework. We were initially drawn to the complexity and richness of <i>Folding and Crumpling of Adaptive Sheets</i>, but its nonlinear modeling and intricate remeshing made it unsuitable for our 4-week timeline. Instead, we chose to build on two well-established resources: <i>Large Steps in Cloth Simulation</i> by Baraff and Witkin [1] and <i>Discrete Shells Origami</i> by Burgoon et al. [2].</p>

            <p>Rather than implementing a full paper-folding or origami simulator (which would require dynamic mesh updates and user-directed fold paths), our goal was to simulate a paper-like material—rigid yet flexible enough to bend and form folds—by extending our existing CS 184 Project 4 cloth simulation with more advanced force models and mesh support.</p>

            <h3>1. Triangle Mesh Support and OBJ Loading</h3>
            <p>We began by replacing the rectangular grid cloth structure in our Project 4 codebase with a general mesh system capable of loading arbitrary triangular meshes from .obj files. We added a new function <code>buildFromOBJ()</code> in <code>cloth.cpp</code> to parse the input file and assign point masses and mesh connectivity accordingly. This enabled us to simulate more complex shapes and configurations, which are necessary for any meaningful folding or bending behavior.</p>

            <h3>2. Physics Engine Upgrade: Implicit Integration and Constraint Modeling</h3>
            <p>To support stiffer, more realistic materials, we transitioned from explicit Verlet integration to the implicit backward Euler integration described in <i>Large Steps in Cloth Simulation</i> [1]. The core formulation involves solving for position and velocity at the next time step using:</p>

            <p class="formula">
                \[\begin{bmatrix}\Delta\vec{x}\\\Delta\vec{v}\end{bmatrix}=h\begin{bmatrix}\vec{v}_t+\Delta\vec{v}\\\mathbf{M}^{-1}\vec{f}\left(\vec{x}_t+\Delta\vec{x},\vec{v}_t+\Delta\vec{v}\right)\end{bmatrix}\]
            </p>

            <p>This method allowed us to use significantly stiffer stretching and bending constraints while maintaining simulation stability. We found this to be essential for approximating the rigidity of paper, particularly during folding or deformation.</p>

            <p>Following the same paper, we implemented per-triangle stretching and shearing constraints based on the deformation gradient, using local UV coordinates and the world-to-object matrix \(\mathbf{D}_{u,v}\). These forces are used to compute the net internal forces and their gradients, feeding into a solver that updates positions and velocities across the mesh.</p>

            <h3>3. Simulating Paper-Like Bending</h3>
            <p>To mimic the behavior of paper folding and creasing, we implemented bending constraints between adjacent triangle faces. While our bending model was simplified compared to the full discrete shell formulation in [2], it captures the essential idea of resisting angular deviation from a rest state. We used angle-based energy terms to apply forces between triangle pairs, allowing the mesh to fold along shared edges.</p>

            <p>We did not implement dynamic mesh modifications such as inserting new fold edges or remeshing triangles, as described in [2]. Instead, we experimented with tuning rest angles and stiffness constants to achieve pseudo-folding effects through simulated forces alone.</p>

            <h3>4. Experimental Creasing (Partial)</h3>
            <p>As part of our exploration into folding, we began testing plastic deformation effects by gradually adjusting rest angles along triangle pairs. This was loosely inspired by the folding mechanism in <i>Discrete Shells Origami</i> [2], where the "rest angle" is incrementally updated to simulate permanent creases. Our approach focused on slowly interpolating the rest state to simulate folding over time without causing instability—avoiding the explosive results that occur when sudden rest-angle changes are applied.</p>

            <p>However, we did not complete a full implementation of plastic folding or track persistent deformation across folds.</p>

            <h3>Problems Encountered</h3>
            <ul>
                <li>
                    <strong>Omission of Shear Constraints Led to Distortion</strong>
                    <p>Initially, we believed triangle meshes would resist shearing due to their angular rigidity. In practice, omitting shear constraints resulted in non-physical distortion. We corrected this by implementing triangle-local shear forces based on the deformation gradient.</p>
                </li>
                <li>
                    <strong>Performance Challenges with High Stiffness</strong>
                    <p>Simulating paper realistically required very high stiffness values, especially for bending. This in turn made the solver slow, requiring hundreds of steps per frame. We addressed this using damping and experimented with reduced stiffness values to strike a balance between speed and realism.</p>
                </li>
                <li>
                    <strong>Unstable Folding Without Gradual Updates</strong>
                    <p>Sharp changes to bending rest angles caused the mesh to oscillate or break. Inspired by [2], we introduced time-based interpolation of rest angles to fold gradually, improving stability.</p>
                </li>
            </ul>

            <h3>Lessons Learned</h3>
            <ul>
                <li>
                    <strong>Shear Forces Are Not Optional in Triangle Meshes</strong>
                    <p>Even with a well-structured mesh, realistic deformation requires explicit modeling of both stretching and shearing.</p>
                </li>
                <li>
                    <strong>Implicit Integration Enables Realistic Stiffness</strong>
                    <p>While more computationally expensive, implicit methods allow for higher fidelity in simulating stiff materials like paper. The tradeoff between accuracy and performance must be tuned carefully.</p>
                </li>
                <li>
                    <strong>Gradual Rest-State Modification Prevents Instability</strong>
                    <p>Trying to force a mesh into a folded state too quickly results in instability. Progressive rest-state updates are essential for simulating fold-like behavior.</p>
                </li>
                <li>
                    <strong>Paper Simulation is Achievable Without Full Origami Modeling</strong>
                    <p>Although we did not implement interactive folding or edge remeshing, we achieved realistic folding effects through force-based simulation alone, showing that a simplified paper model can still produce meaningful visual results.</p>
                </li>
            </ul>
        </section>

        <section id="results">
            <h2>Results</h2>
            <p>We managed to replicate the results of Homework 4 using our new cloth simulation model, and we can now render arbitrary triangle meshes from compatible <code>.obj</code> files. Below are two images that show the features we have implemented.</p>
            
            <div class="image-gallery">
                <div class="image-card">
                    <img src="images/bunny.png" alt="Bunny Mesh in Cloth Simulator">
                    <figcaption>Bunny Mesh in Cloth Simulator</figcaption>
                </div>
                <div class="image-card">
                    <img src="images/cloth.png" alt="Cloth on Ball Using New Model">
                    <figcaption>Cloth on Ball Using New Model</figcaption>
                </div>
            </div>
            
            <p>Once we implement bending constraints, we will be able to simulate more complex cloth and paper behavior.</p>
        </section>

        <section id="progress">
            <h2>Progress</h2>
            <p>We are somewhat behind compared to our proposal timeline due to the fact that we spent a significant portion of the last two weeks deciding what new model we should use for our paper simulation. But, we have now created the basic mesh infrastructure required to develop our demos and ensure physics are generalizeable to arbitrary meshes. In the next two weeks, we plan to complete the bending constraint code, and finally implement the meat of the <i>Discrete Shells Origami</i> paper. Given that this new paper allows us to simulate simple origami paper folding, we will now attempt to make our primary demo one where we fold a basic origami pattern, rather than just standard paper simulation.</p>

            <p>Additionally, we have to clean-up some of the integration of our new model with the pre-existing Homework 4 starter code. For example, we need to properly be able to show the structure/"wireframe" of our mesh even with the new mesh structure that doesn't separate the springs from the triangle mesh object. On top of this, we need to optimize the speed of the simulation using some more of the optimizations in <i>Large Steps in Cloth Simulation</i>. In particular, there is a nice optimization in this paper that allows us to limit the number of coordinates that we need to consider when calculating a point mass's future velocity and position.</p>
        </section>

        <section id="resources">
            <h2>Resources</h2>
            <ul class="resources-list">
                <li>
                    <span class="resource-type">(Paper)</span> Discrete Shells Origami: 
                    <a href="https://www.cs.columbia.edu/cg/pdfs/115-origami-CATA-2006.pdf" target="_blank">cs.columbia.edu/cg/pdfs/115-origami-CATA-2006.pdf</a>
                </li>
                <li>
                    <span class="resource-type">(Paper)</span> Large Steps in Cloth Simulation: 
                    <a href="https://www.cs.cmu.edu/~baraff/papers/sig98.pdf" target="_blank">cs.cmu.edu/~baraff/papers/sig98.pdf</a>
                </li>
                <li>
                    <span class="resource-type">(Library)</span> CGL Vectors Library: 
                    <a href="https://cs184.eecs.berkeley.edu/sp25/resources/cgl-vector-docs/" target="_blank">cs184.eecs.berkeley.edu/sp25/resources/cgl-vector-docs/</a>
                </li>
                <li>
                    <span class="resource-type">(Code)</span> CS 184 Project 4 Starter Code
                </li>
            </ul>
        </section>
    </div>

    <footer>
        <p>CS 184: Computer Graphics and Imaging | University of California, Berkeley</p>
    </footer>
    <style>
        :root {
            --primary-color: #2563eb;
            --secondary-color: #1e40af;
            --accent-color: #dbeafe;
            --text-color: #1f2937;
            --light-text: #4b5563;
            --background-color: #ffffff;
            --section-bg: #f9fafb;
            --code-bg: #f3f4f6;
            --border-color: #e5e7eb;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: 'Inter', sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            background-color: var(--background-color);
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 0 20px;
        }

        header {
            background: linear-gradient(to right, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 3rem 0;
            text-align: center;
            margin-bottom: 2rem;
        }

        .header-content {
            max-width: 800px;
            margin: 0 auto;
        }

        h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 1rem;
        }

        .team-info {
            font-size: 1.1rem;
            margin-bottom: 1.5rem;
            font-weight: 400;
        }

        .links-section {
            display: flex;
            justify-content: center;
            gap: 1.5rem;
            flex-wrap: wrap;
            margin: 1.5rem 0;
        }

        .link-card {
            background-color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            transition: transform 0.2s;
        }

        .link-card:hover {
            transform: translateY(-3px);
        }

        .link-card img {
            width: 24px;
            height: 24px;
            margin-right: 8px;
        }

        .link-card a {
            color: var(--primary-color);
            text-decoration: none;
            font-weight: 500;
        }

        section {
            margin-bottom: 3rem;
            background-color: var(--section-bg);
            border-radius: 10px;
            padding: 2rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        h2 {
            color: var(--primary-color);
            font-size: 1.75rem;
            margin-bottom: 1.25rem;
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 0.5rem;
        }

        h3 {
            color: var(--secondary-color);
            font-size: 1.3rem;
            margin-top: 1.75rem;
            margin-bottom: 0.75rem;
            font-weight: 600;
        }

        p {
            margin-bottom: 1.5rem;
            color: var(--text-color);
        }

        .formula {
            margin: 1.5rem 0;
            padding: 1.5rem;
            background-color: var(--accent-color);
            border-radius: 8px;
            text-align: center;
            overflow-x: auto;
        }

        ul {
            margin-left: 2rem;
            margin-bottom: 1.5rem;
        }

        li {
            margin-bottom: 0.75rem;
        }

        li strong {
            color: var(--secondary-color);
            font-weight: 600;
        }

        li p {
            margin-top: 0.25rem;
            margin-bottom: 0.75rem;
        }

        code {
            font-family: monospace;
            background-color: var(--code-bg);
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            font-size: 0.9em;
        }

        .image-gallery {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 2rem;
            margin: 2rem 0;
        }

        .image-card {
            text-align: center;
            background-color: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            padding-bottom: 1rem;
        }

        .image-card img {
            width: 100%;
            max-width: 100%;
            height: auto;
            object-fit: cover;
            display: block;
            border-bottom: 1px solid var(--border-color);
        }

        figcaption {
            padding: 1rem;
            font-weight: 500;
            color: var(--light-text);
        }

        a {
            color: var(--primary-color);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--secondary-color);
            text-decoration: underline;
        }

        .resources-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1rem;
            list-style: none;
            margin-left: 0;
        }

        .resources-list li {
            background: white;
            padding: 1rem;
            border-radius: 8px;
            border-left: 4px solid var(--primary-color);
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .resource-type {
            font-weight: 600;
            color: var(--primary-color);
        }

        footer {
            text-align: center;
            padding: 2rem;
            margin-top: 3rem;
            background-color: var(--section-bg);
            color: var(--light-text);
            font-size: 0.9rem;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
            }
            
            .image-gallery {
                grid-template-columns: 1fr;
            }
            
            section {
                padding: 1.5rem;
            }
        }
    </style>
</body>
</html>